<div id="cookie-notice">
        <div>
            <span> {{ i18n "cookieconsent_message" }}
                {{ with site.Params.privacyPolicyUrl }}<a href="{{ . }}">{{ i18n "privacy_policy" }}</a>{{ end }}</span>
        </div>
        <div class="div-buttons-cookies">
            <button id="cookie-notice-accept" class="buttons-cookies btn btn-primary btn-sm ">{{ i18n "cookieconsent_accept" }}</button>
            <button id="cookie-notice-deny" class="buttons-cookies buttons-cookies-decline btn btn-primary btn-sm">{{ i18n "cookieconsent_decline" }}</button>
        </div>
    
</div>
<div id="cookies-overlay"></div>

<script >
function mostrarBannerCookies() {
  document.body.classList.add('cookies-modal-open');
}

function ocultarBannerCookies() {
  document.body.classList.remove('cookies-modal-open');
  var over = document.getElementById('cookies-overlay');
  if (over) {
    over.remove();
  }
}

function createCookie(name, value, days) {
  var expires = "";
  if (days) {
    var date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    expires = "; expires=" + date.toUTCString();
  }
  document.cookie = name + "=" + value + expires + "; path=/" + ";secure;SameSite=None";
}
function readCookie(name) {
  var nameEQ = name + "=";
  var ca = document.cookie.split(';');
  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') c = c.substring(1, c.length);
    if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
  }
  return null;
}

function deleteCookiesByPattern(pattern) {
  const cookies = document.cookie.split(';');

  for (let i = 0; i < cookies.length; i++) {

    const cookie = cookies[i];
    const eqPos = cookie.indexOf("=");
    const name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;

    if (name.includes(pattern)) {
      document.cookie = name + "=; Domain=.kore-ledger.net; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; secure; SameSite=None";
    }
  }
}

if (readCookie('cookie-notice-option') == 'true') {
  function loadScriptAsync(scriptSrc, callback) {
    if (typeof callback !== 'function') {
      throw new Error('Not a valid callback for async script load');
    }
    var script = document.createElement('script');
    script.onload = callback;
    script.src = scriptSrc;
    document.head.appendChild(script);
  }

  loadScriptAsync('https://www.googletagmanager.com/gtag/js?id=G-1TBWRM0BXF', function () {
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-1TBWRM0BXF', { 'anonymize_ip': true, cookie_flags: 'secure;samesite=none' });
  })

} else if (readCookie('cookie-notice-option') != 'false') {
  mostrarBannerCookies();
  deleteCookiesByPattern("_ga");
  document.getElementById('cookie-notice').style.display = 'block';
} else if (readCookie('cookie-notice-option') == 'false') {
  deleteCookiesByPattern("_ga");
  document.getElementById('cookie-notice').style.display = 'none';
}

document.getElementById('cookie-notice-accept').addEventListener("click", function () {

  createCookie('cookie-notice-option', 'true', 31);
  document.getElementById('cookie-notice').style.display = 'none';
  ocultarBannerCookies();
  location.reload();
});

document.getElementById('cookie-notice-deny').addEventListener("click", function () {
  createCookie('cookie-notice-option', 'false', 1);
  document.getElementById('cookie-notice').style.display = 'none';
  location.reload();
});


class Accordion {
  constructor(el) {
    // Store the <details> element
    this.el = el;
    // Store the <summary> element
    this.summary = el.querySelector('summary');
    // Store the <div class="content"> element
    this.content = el.querySelector('.content');

    // Store the animation object (so we can cancel it if needed)
    this.animation = null;
    // Store if the element is closing
    this.isClosing = false;
    // Store if the element is expanding
    this.isExpanding = false;
    // Detect user clicks on the summary element
    this.summary.addEventListener('click', (e) => this.onClick(e));
  }

  onClick(e) {
    // Stop default behaviour from the browser
    e.preventDefault();
    console.log('click');
    // Add an overflow on the <details> to avoid content overflowing
    this.el.style.overflow = 'hidden';
    // Check if the element is being closed or is already closed
    if (this.isClosing || !this.el.open) {
      this.open();
    // Check if the element is being openned or is already open
    } else if (this.isExpanding || this.el.open) {
      this.shrink();
    }
  }

  shrink() {
    // Set the element as "being closed"
    this.isClosing = true;
    
    // Store the current height of the element
    const startHeight = `${this.el.offsetHeight}px`;
    // Calculate the height of the summary
    const endHeight = `${this.summary.offsetHeight}px`;
    
    // If there is already an animation running
    if (this.animation) {
      // Cancel the current animation
      this.animation.cancel();
    }
    
    // Start a WAAPI animation
    this.animation = this.el.animate({
      // Set the keyframes from the startHeight to endHeight
      height: [startHeight, endHeight]
    }, {
      duration: 400,
      easing: 'ease-out'
    });
    
    // When the animation is complete, call onAnimationFinish()
    this.animation.onfinish = () => this.onAnimationFinish(false);
    // If the animation is cancelled, isClosing variable is set to false
    this.animation.oncancel = () => this.isClosing = false;
  }

  open() {
    // Apply a fixed height on the element
    this.el.style.height = `${this.el.offsetHeight}px`;
    // Force the [open] attribute on the details element
    this.el.open = true;
    // Wait for the next frame to call the expand function
    window.requestAnimationFrame(() => this.expand());
  }

  expand() {
    // Set the element as "being expanding"
    this.isExpanding = true;
    // Get the current fixed height of the element
    const startHeight = `${this.el.offsetHeight}px`;
    // Calculate the open height of the element (summary height + content height)
    const endHeight = `${this.summary.offsetHeight + this.content.offsetHeight}px`;
    
    // If there is already an animation running
    if (this.animation) {
      // Cancel the current animation
      this.animation.cancel();
    }
    
    // Start a WAAPI animation
    this.animation = this.el.animate({
      // Set the keyframes from the startHeight to endHeight
      height: [startHeight, endHeight]
    }, {
      duration: 400,
      easing: 'ease-out'
    });
    // When the animation is complete, call onAnimationFinish()
    this.animation.onfinish = () => this.onAnimationFinish(true);
    // If the animation is cancelled, isExpanding variable is set to false
    this.animation.oncancel = () => this.isExpanding = false;
  }

  onAnimationFinish(open) {
    // Set the open attribute based on the parameter
    this.el.open = open;
    // Clear the stored animation
    this.animation = null;
    // Reset isClosing & isExpanding
    this.isClosing = false;
    this.isExpanding = false;
    // Remove the overflow hidden and the fixed height
    this.el.style.height = this.el.style.overflow = '';
  }
}

document.querySelectorAll('.details-warning').forEach((el) => {
    
    console.log("sdasdasda");
  new Accordion(el);
  
});
</script>